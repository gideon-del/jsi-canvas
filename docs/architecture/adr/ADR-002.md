# ADR-002: Scene Graph in Shared C++

**Date:** 2025-12-30
**Status:** Accepted
**Deciders:** Gideon

## Context

We need to store thousands of shapes efficiently. Each shape has geometry, styling, and needs to be queryable by position and ID. This data structure will be accessed during:

- Rendering (60fps)
- Hit testing (on every tap)
- Creation/deletion of nodes
- Spatial queries (find nodes in viewport)

Options for implementation:

1. JavaScript (in React state)
2. Native platform types (Swift/Kotlin)
3. Shared C++

## Decision

Implement scene graph in shared C++ code, accessible from both iOS and Android.

## Rationale

**Performance:**

- C++ is compiled and optimized
- No JS bridge overhead for queries
- Direct memory access from native rendering
- Spatial algorithms (R-tree, grid) are well-established in C++

**Code Reuse:**

- Write once, use on both platforms
- Single source of truth
- Fix bugs in one place
- Consistent behavior guaranteed

**Memory Efficiency:**

- Full control over memory layout
- Can use `unique_ptr` for automatic cleanup
- No GC overhead
- Smaller memory footprint than JS objects

**JSI Integration:**

- C++ can be directly called from JS via JSI
- Zero-copy access (no serialization)
- Synchronous calls possible
- Can share actual C++ objects with JS

## Consequences

### Positive

- 50-100x better query performance than JS
- 10x better memory efficiency than JS
- Platform parity guaranteed (same code)
- Future-proof (can add Metal/Vulkan later)
- Team learns valuable C++ skills

### Negative

- Higher learning curve than JS/Kotlin/Swift
- Longer compile times (C++ is slow to compile)
- Harder to debug (no console.log)
- Need to manage memory manually (though `unique_ptr` helps)
- Need to build for both iOS and Android separately

### Neutral

- Need to write unit tests in C++ (actually a good thing)
- Need to understand threading (will learn proper patterns)

## Alternatives Considered

### Alternative 1: JavaScript (React State)

```typescript
const [nodes, setNodes] = useState<Node[]>([]);
```

**Pros:**

- Familiar for React developers
- Easy to debug (console.log everywhere)
- Fast iteration (no compilation)

**Cons:**

- Terrible performance (1000+ nodes lag)
- Need to serialize for native rendering
- JS bridge overhead kills 60fps
- High memory usage (JS objects are large)

**Why rejected:** Performance requirements cannot be met.

---

### Alternative 2: Platform-Native (Swift + Kotlin)

**iOS:** Swift structs/classes
**Android:** Kotlin data classes

**Pros:**

- Native to each platform
- Good IDE support
- Platform idiomatic

**Cons:**

- Write everything twice (iOS + Android)
- Bugs need fixing twice
- Subtle platform differences likely
- Can't share code
- More maintenance burden

**Why rejected:** Code duplication is unacceptable for MVP.

---

### Alternative 3: Hybrid (C++ for data, platform code for logic)

**Pros:**

- Best of both worlds?
- Platform code can be more idiomatic

**Cons:**

- Complexity: Now have THREE implementations
- Difficult to maintain consistency
- Where does each piece go? Unclear boundaries
- Mixing languages is confusing

**Why rejected:** Adds complexity without clear benefits.

## Implementation Plan

1. **Sprint 2 Day 1:** Implement C++ scene graph
2. **Sprint 2 Day 2:** Add spatial indexing
3. **Sprint 2 Day 3-4:** Integrate with iOS and Android rendering
4. **Sprint 3:** Expose via JSI to JavaScript

## Validation

We'll measure success by:

- Query 10,000 nodes in < 5ms
- Add/remove node in < 1ms
- Memory usage < 2MB for 10,000 nodes
- Hit test in < 0.1ms
- Platform parity (pixel-perfect match iOS/Android)

## References

- [Spatial Data Structures Comparison](https://en.wikipedia.org/wiki/Spatial_database)
- Inspiration: Figma's approach (C++ engine, thin platform layers)
