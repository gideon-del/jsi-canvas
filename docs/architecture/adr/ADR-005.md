# ADR-005: Camera State Storage (C++ vs Native)

**Date:** 2025-12-31  
**Status:** Accepted  
**Deciders:** [Your Name]

## Context

The camera state defines how the canvas is viewed:

```cpp
struct CameraState {
    float offsetX;    // Pan position X
    float offsetY;    // Pan position Y
    float zoom;       // Zoom level (0.1 to 10.0)
};
```

This state is critical for:

1. **Transform calculations:** Converting world â†” screen coordinates
2. **Gesture updates:** Pan/zoom modify camera state
3. **Rendering:** Every frame reads camera state
4. **Viewport culling:** Query visible nodes based on camera

**The question:** Where should camera state live?

### Options

**Option A: JavaScript (React State)**

```typescript
const [camera, setCamera] = useState({
  offsetX: 0,
  offsetY: 0,
  zoom: 1.0,
});
```

**Option B: Native platform types**

```objc
// iOS
@interface CanvasView : UIView {
    float offsetX;
    float offsetY;
    float zoom;
}

// Android
class CanvasView : View {
    private var offsetX: Float = 0f
    private var offsetY: Float = 0f
    private var zoom: Float = 1.0f
}
```

**Option C: Shared C++ structure**

```cpp
// C++ (used by both iOS and Android)
struct CameraState {
    float offsetX = 0;
    float offsetY = 0;
    float zoom = 1.0f;

    CGPoint worldToScreen(CGPoint world, CGSize viewSize);
    CGPoint screenToWorld(CGPoint screen, CGSize viewSize);
};
```

## Decision

**Store camera state in a shared C++ struct** (`CameraState`) that is owned by the native view and used directly for all transform calculations.

**Architecture:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Native View (iOS/Android)          â”‚
â”‚                                     â”‚
â”‚  CanvasView {                       â”‚
â”‚    CameraState* camera_;  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€ Single source of truth
â”‚  }                                  â”‚
â”‚                                     â”‚
â”‚  Gestures read/write camera_       â”‚
â”‚  Rendering reads camera_            â”‚
â”‚  Transform math uses camera_        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†‘
           â”‚ (Future: Sprint 3)
           â”‚ JSI can read camera state
           â”‚ for debugging/inspection
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  JavaScript (Optional)              â”‚
â”‚                                     â”‚
â”‚  const zoom = canvasDoc.getZoom();  â”‚
â”‚  // Read-only from JS               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Rationale

### 1. Single Source of Truth

**Problem with multiple copies:**

```
If camera state is duplicated:

Native has: offsetX = 100
JS has: offsetX = 95  // Out of sync!
C++ has: offsetX = 100

Which is correct? Nobody knows!
Bugs: Visual glitches, incorrect hit testing
```

**Solution with C++ single source:**

```
Only one place: C++ CameraState
Native reads it: Direct pointer access
JS reads it (Sprint 3): Via JSI
SceneGraph reads it: Direct pointer access

Always in sync! âœ“
```

### 2. Performance: Zero-Copy Transform Math

**Every frame, thousands of transforms:**

```cpp
// Render loop (60fps)
for (Node* node : visibleNodes) {
    // Convert world bounds to screen bounds
    CGRect screenBounds = camera_.worldToScreen(node->bounds);
    drawRect(screenBounds);
}

// Hit test on tap
CGPoint worldPos = camera_.screenToWorld(tapLocation);
Node* hit = sceneGraph.hitTest(worldPos.x, worldPos.y);
```

**If camera were in JS:**

```typescript
// Every transform would require:
1. JS â†’ Native bridge crossing (1-2ms)
2. Deserialize camera data
3. Calculate transform
4. Return result
5. Native â† JS bridge crossing (1-2ms)

Cost per frame: 2-4ms Ã— hundreds of transforms = SLOW!
```

**With C++ camera:**

```cpp
// Direct memory access
CGRect screenBounds = camera_.worldToScreen(node->bounds);

Cost per transform: < 0.001ms
No bridge, no serialization, just math!
```

**Measurement:**

```
1000 transforms per frame:

JS camera: ~10ms
C++ camera: ~0.1ms

100x faster!
```

### 3. Code Reuse: One Implementation, Two Platforms

**Transform math is identical on iOS and Android:**

```cpp
// CameraState.h - SHARED CODE
struct CameraState {
    float offsetX, offsetY, zoom;

    // This works on both iOS and Android!
    CGPoint worldToScreen(CGPoint world, CGSize viewSize) {
        return CGPointMake(
            (world.x + offsetX) * zoom,
            (world.y + offsetY) * zoom
        );
    }

    CGPoint screenToWorld(CGPoint screen, CGSize viewSize) {
        return CGPointMake(
            (screen.x / zoom) - offsetX,
            (screen.y / zoom) - offsetY
        );
    }
};
```

**Used by both platforms:**

```objc
// iOS - CanvasView.mm
#import "CameraState.h"

@implementation CanvasView {
    CanvasMVP::CameraState camera_;
}

- (void)drawRect:(CGRect)rect {
    auto nodes = sceneGraph_.queryVisible(...);
    for (auto* node : nodes) {
        CGRect screen = camera_.worldToScreen(node->bounds, self.bounds.size);
        // Draw...
    }
}
@end
```

```kotlin
// Android - CanvasView.kt
data class CameraState(
    var offsetX: Float = 0f,
    var offsetY: Float = 0f,
    var zoom: Float = 1.0f
) {
    fun worldToScreen(world: PointF, viewSize: SizeF): PointF {
        return PointF(
            (world.x + offsetX) * zoom,
            (world.y + offsetY) * zoom
        )
    }

    fun screenToWorld(screen: PointF, viewSize: SizeF): PointF {
        return PointF(
            (screen.x / zoom) - offsetX,
            (screen.y / zoom) - offsetY
        )
    }
}
```

**Benefits:**

- Fix transform bug once, fixed on both platforms
- Add feature once, available on both platforms
- Test once, confidence on both platforms

### 4. Direct Access from SceneGraph Queries

**SceneGraph needs camera for viewport culling:**

```cpp
// Every frame: Calculate what's visible
void CanvasView::drawRect(CGRect rect) {
    // Calculate world-space viewport
    CGPoint topLeft = camera_.screenToWorld(CGPointZero, self.bounds.size);
    CGPoint bottomRight = camera_.screenToWorld(
        CGPointMake(rect.size.width, rect.size.height),
        self.bounds.size
    );

    Rect viewport{
        topLeft.x, topLeft.y,
        bottomRight.x - topLeft.x,
        bottomRight.y - topLeft.y
    };

    // Query scene graph
    auto visibleNodes = sceneGraph_.queryVisible(viewport);

    // Render...
}
```

**If camera were separate:**

```
Option 1: Pass camera to every function
  â†’ Lots of parameters everywhere

Option 2: SceneGraph stores camera reference
  â†’ Works, but coupling

Option 3: Recalculate viewport in JS
  â†’ Bridge overhead, defeats purpose
```

**With C++ camera:**

```cpp
// Native view owns camera
// Passes it to functions that need it
// Simple, efficient, clear ownership
```

### 5. Future: JSI Can Read Camera (Sprint 3)

**Sometimes JS needs camera info:**

```typescript
// Show zoom level in UI
const zoomLevel = canvasDocument.getZoom();
<Text>Zoom: {zoomLevel.toFixed(1)}x</Text>;

// Show camera position for debugging
const cameraPos = canvasDocument.getCameraPosition();
console.log(`Camera at (${cameraPos.x}, ${cameraPos.y})`);

// Calculate something in JS (rare)
const worldPos = canvasDocument.screenToWorld(screenX, screenY);
```

**With C++ camera + JSI:**

```cpp
// Expose to JS (Sprint 3)
class CanvasDocument : public jsi::HostObject {
    CameraState* camera_;

public:
    jsi::Value get(jsi::Runtime& rt, const jsi::PropNameID& name) {
        if (name.utf8(rt) == "zoom") {
            return jsi::Value(camera_->zoom);
        }
        if (name.utf8(rt) == "offsetX") {
            return jsi::Value(camera_->offsetX);
        }
        // ...
    }
};
```

**JS can now read (but not write!):**

```typescript
const zoom = canvasDocument.zoom; // Reads C++ directly!
const x = canvasDocument.offsetX; // Zero-copy access
```

**This is only possible with C++ storage!**

### 6. Ownership is Clear

**Camera lifecycle:**

```
Created: When CanvasView is created
Updated: By gestures (pan/zoom)
Read: By rendering, queries, transforms
Destroyed: When CanvasView is destroyed

Owner: CanvasView (native)
Lifetime: Tied to view lifetime
```

**Clear ownership = No memory leaks, no confusion**

```objc
@implementation CanvasView {
    CanvasMVP::CameraState camera_;  // Owned by view
}

- (void)dealloc {
    // camera_ automatically destroyed (C++ struct)
}
@end
```

## Consequences

### Positive

âœ… **Single source of truth**

- No synchronization bugs
- No "which value is correct?" confusion
- State consistency guaranteed

âœ… **Maximum performance**

- Zero-copy transforms (100x faster than JS)
- Direct memory access
- No bridge overhead
- Math happens at native speed

âœ… **Code reuse across platforms**

- Write transform math once (C++)
- Both platforms use same code
- Fix bugs once
- Platform parity guaranteed

âœ… **Simple ownership model**

- Native view owns camera
- Lifetime tied to view
- No manual memory management needed
- No leaks possible

âœ… **Future-proof for JSI**

- JS can read camera state (Sprint 3)
- Zero-copy access via JSI
- No performance penalty
- Optional, not required

âœ… **Thread-safe design**

```
Camera is accessed from:
- UI thread only (gestures, rendering)

No multi-threading issues!
No locks needed!
```

### Negative

âš ï¸ **JS cannot write camera state directly**

```typescript
// This DOESN'T work:
canvasDocument.zoom = 2.0; // âœ— Read-only!
canvasDocument.offsetX = 100; // âœ— Cannot set!

// Must use methods (Sprint 3+):
canvasDocument.setZoom(2.0);
canvasDocument.panTo(100, 200);
```

**Rationale:** This is intentional!

- Gestures must control camera (not JS)
- JS controlling camera defeats native architecture
- If JS needs to move camera, it's for specific actions (rare)

**Workaround (Sprint 3+):**

```cpp
// Expose methods to JS
class CanvasDocument : public jsi::HostObject {
    void setZoom(double zoom) {
        camera_->zoom = clamp(zoom, 0.1, 10.0);
        notifyRedraw();
    }

    void panTo(double x, double y) {
        camera_->offsetX = x;
        camera_->offsetY = y;
        notifyRedraw();
    }
};
```

âš ï¸ **Platform duplication for Android**

```
iOS: Uses C++ CameraState directly
Android: Must reimplement in Kotlin

Result: 2 implementations of same logic
```

**Mitigation:**

- Transform math is simple (10-20 lines)
- Copy from C++ to Kotlin (5 minutes)
- Can wrap C++ via JNI if needed (Sprint 6+)

**Decision:** Duplication acceptable for MVP simplicity

âš ï¸ **Camera state not in React DevTools**

```
React DevTools shows:
- Component state âœ“
- Props âœ“

Does NOT show:
- Camera state âœ—

Debugging: Must add explicit logging
```

**Mitigation (Sprint 3):**

```typescript
// Add debug overlay
const CameraDebug = () => {
  const [camera, setCamera] = useState({ zoom: 1, x: 0, y: 0 });

  useEffect(() => {
    const interval = setInterval(() => {
      setCamera({
        zoom: canvasDocument.zoom,
        x: canvasDocument.offsetX,
        y: canvasDocument.offsetY,
      });
    }, 100);
    return () => clearInterval(interval);
  }, []);

  return (
    <Text style={styles.debug}>
      Zoom: {camera.zoom.toFixed(2)}x Position: ({camera.x.toFixed(0)},{' '}
      {camera.y.toFixed(0)})
    </Text>
  );
};
```

### Neutral

âšª **Camera transform math must be correct**

```
If bugs in worldToScreen/screenToWorld:
- Rendering will be wrong
- Hit testing will be wrong
- Gestures will feel broken

But: Math is simple, well-tested
```

**Mitigation:**

- Unit tests for transform functions
- Visual tests (draw grid, verify alignment)
- Test at extreme zoom levels (0.1x, 10x)

âšª **Need to understand coordinate systems**

```
World space: Infinite canvas coordinates
Screen space: Device pixel coordinates

Must understand both to debug
```

**This is necessary regardless of where camera lives!**

## Alternatives Considered

### Alternative 1: JavaScript (React State)

**Description:** Store camera in React state, pass to native

```typescript
const [camera, setCamera] = useState({
  offsetX: 0,
  offsetY: 0,
  zoom: 1.0,
});

<CanvasView
  cameraOffsetX={camera.offsetX}
  cameraOffsetY={camera.offsetY}
  cameraZoom={camera.zoom}
/>;
```

**Pros:**

- Easy to debug (React DevTools)
- Can use React state management
- Easy to save/restore (JSON)
- Can control from JS

**Cons:**

- **Breaks gesture performance!**

  ```
  Gesture update flow:
  Native detects â†’ Sends to JS â†’ JS updates state â†’
  React re-renders â†’ Prop to native â†’ Native updates

  Latency: 16-50ms (1-3 frames delay!)
  Feels laggy!
  ```

- Bridge overhead every frame
- Fails "Freeze JS" test
- Camera state duplicated (JS + Native)

**Benchmark:**

```
Native camera: 60fps solid, < 16ms latency
JS camera: 40-50fps, 30-50ms latency

User experience: Terrible!
```

**Why rejected:** Completely breaks gesture performance. Non-starter.

---

### Alternative 2: Native Platform Types Only

**Description:** Store camera in native iOS/Android types

```objc
// iOS
@interface CanvasView : UIView
@property (nonatomic) float offsetX;
@property (nonatomic) float offsetY;
@property (nonatomic) float zoom;
@end
```

```kotlin
// Android
class CanvasView : View {
    var offsetX: Float = 0f
    var offsetY: Float = 0f
    var zoom: Float = 1.0f
}
```

**Pros:**

- Platform idiomatic
- No C++ needed
- Simple to implement

**Cons:**

- **Duplicate implementation required!**

  ```
  iOS: worldToScreen in Objective-C
  Android: worldToScreen in Kotlin

  Bug in iOS? Must fix in Android too!
  Add feature? Must implement twice!
  ```

- No code reuse
- Platform parity not guaranteed
- More maintenance burden

**Why rejected:**

```
Transform math is ~50 lines
With duplication: 100 lines total
With C++: 50 lines total

C++ version saves work AND guarantees consistency!
```

---

### Alternative 3: Pass Camera Every Frame via Props

**Description:** JS calculates transforms, passes results to native

```typescript
const [camera, setCamera] = useState({ ... });

// Calculate transforms in JS
const transformedNodes = nodes.map(node => ({
  ...node,
  screenBounds: worldToScreen(node.bounds, camera)
}));

<CanvasView transformedNodes={transformedNodes} />
```

**Pros:**

- All logic in JS (easier for JS developers)
- Can use JS libraries for math

**Cons:**

- **Catastrophic performance!**

  ```
  For 1000 visible nodes:
  1. JS calculates 1000 transforms
  2. Serialize 1000 node objects
  3. Cross bridge (1000 Ã— 40 bytes = 40KB)
  4. Native deserializes 1000 objects
  5. Native renders

  Time: 20-50ms per frame
  FPS: 20-30fps

  COMPLETELY UNACCEPTABLE!
  ```

**Why rejected:** Would make canvas completely unusable. Never do this!

---

### Alternative 4: Hybrid (Camera in C++, Transforms in JS)

**Description:** Camera state in C++, but JS does transform calculations

```typescript
// JS reads camera state
const camera = canvasDocument.getCameraState();

// JS does transform math
const screenPos = worldToScreen(worldPos, camera);

// Pass results to native
canvasDocument.renderNode(node, screenPos);
```

**Pros:**

- Camera state in C++ (single source of truth)
- JS can inspect and modify
- Flexibility

**Cons:**

- Defeats purpose of C++ camera
- Still have bridge overhead
- JS math slower than C++
- More complex (split responsibility)

**Why rejected:**

```
If camera is in C++:
  â†’ Transform math should be in C++ too!
  â†’ Avoid bridge overhead
  â†’ Keep related code together
```

---

## Implementation Plan

### Sprint 1 Day 3: Camera System (8 hours)

**Morning (3 hours) - C++ Implementation:**

Create `ios/Canvas/CameraState.h`:

```cpp
#ifndef CameraState_h
#define CameraState_h

#include <CoreGraphics/CoreGraphics.h>
#include <algorithm>

namespace CanvasMVP {

struct CameraState {
    float offsetX = 0.0f;
    float offsetY = 0.0f;
    float zoom = 1.0f;

    // Clamp zoom to valid range
    void setZoom(float newZoom) {
        zoom = std::clamp(newZoom, 0.1f, 10.0f);
    }

    // World â†’ Screen transform
    CGPoint worldToScreen(CGPoint world, CGSize viewSize) const {
        return CGPointMake(
            (world.x + offsetX) * zoom,
            (world.y + offsetY) * zoom
        );
    }

    // Screen â†’ World transform
    CGPoint screenToWorld(CGPoint screen, CGSize viewSize) const {
        return CGPointMake(
            (screen.x / zoom) - offsetX,
            (screen.y / zoom) - offsetY
        );
    }

    // Transform rectangle
    CGRect worldToScreen(CGRect world, CGSize viewSize) const {
        CGPoint origin = worldToScreen(world.origin, viewSize);
        return CGRectMake(
            origin.x,
            origin.y,
            world.size.width * zoom,
            world.size.height * zoom
        );
    }
};

} // namespace CanvasMVP

#endif
```

**Afternoon (3 hours) - iOS Integration:**

```objc
// CanvasView.mm
#import "CameraState.h"

@implementation CanvasView {
    CanvasMVP::CameraState camera_;
}

- (void)drawRect:(CGRect)rect {
    // Use camera for transforms
    // ... (integrated with existing drawing code)
}
@end
```

**Evening (2 hours) - Testing:**

- Unit tests for transform math
- Visual test: Draw grid with camera transform
- Test at extreme zoom (0.1x, 10x)
- Test with negative coordinates

**Android (Sprint 1 Day 3 - parallel or after iOS):**

```kotlin
data class CameraState(
    var offsetX: Float = 0f,
    var offsetY: Float = 0f,
    var zoom: Float = 1.0f
) {
    fun setZoom(newZoom: Float) {
        zoom = newZoom.coerceIn(0.1f, 10.0f)
    }

    fun worldToScreen(world: PointF, viewSize: SizeF): PointF {
        return PointF(
            (world.x + offsetX) * zoom,
            (world.y + offsetY) * zoom
        )
    }

    fun screenToWorld(screen: PointF, viewSize: SizeF): PointF {
        return PointF(
            (screen.x / zoom) - offsetX,
            (screen.y / zoom) - offsetY
        )
    }
}
```

---

## Validation

**Success criteria:**

- [ ] Transform math is correct (grid aligns with coordinates)
- [ ] Gestures use camera directly (no bridge crossings)
- [ ] Rendering uses camera directly (no performance impact)
- [ ] iOS and Android produce identical results (platform parity)
- [ ] Camera works at extreme zoom (0.1x and 10.0x)
- [ ] Camera works with negative coordinates

**Test plan:**

1. **Visual test:** Draw grid at (0, 0), pan camera, verify grid moves
2. **Math test:** Unit tests for worldToScreen/screenToWorld
3. **Gesture test:** Pan and zoom, verify smooth 60fps
4. **Extreme test:** Zoom to 0.1x and 10.0x, verify rendering
5. **Negative coords:** Pan to (-1000, -1000), verify works
6. **Parity test:** Run on iOS and Android, take screenshots, compare

---

## Future Enhancements

**Sprint 3: Expose to JSI**

```cpp
class CanvasDocument : public jsi::HostObject {
    CameraState* camera_;

    jsi::Value get(jsi::Runtime& rt, const jsi::PropNameID& name) {
        auto nameStr = name.utf8(rt);
        if (nameStr == "zoom") return jsi::Value(camera_->zoom);
        if (nameStr == "offsetX") return jsi::Value(camera_->offsetX);
        if (nameStr == "offsetY") return jsi::Value(camera_->offsetY);
        // ...
    }
};
```

**Sprint 5+: Advanced Camera Features**

- Zoom to fit (zoom to show all nodes)
- Animate camera transitions
- Rotation support (2D rotation)
- Bounds limiting (keep canvas in view)

**Sprint 6+: Optimize Android with JNI**

```
If Android performance is concern:
1. Wrap C++ CameraState with JNI
2. Kotlin calls C++ directly
3. Eliminate duplication
```

---

## References

- [Coordinate System Design Patterns](https://en.wikipedia.org/wiki/World_coordinate_system)
- [Camera Systems in 2D Games](https://www.gamasutra.com/blogs/ItayKeren/20150511/243083/Scroll_Back_The_Theory_and_Practice_of_Cameras_in_SideScrollers.php)
- [React Native Performance Best Practices](https://reactnative.dev/docs/performance)

---

## Approval

This ADR establishes the **camera state as a first-class C++ citizen** that:

- âœ… Maximizes performance (zero-copy transforms)
- âœ… Ensures single source of truth (no sync issues)
- âœ… Enables code reuse (write once, use twice)
- âœ… Supports future JSI integration (optional read access)
- âœ… Maintains clear ownership (native view owns camera)

**Approved for Sprint 1 Day 3 implementation.**

---

Excellent work on completing Sprint 0! These three ADRs complete your architecture planning and you're now fully prepared to start Sprint 1 with confidence. ðŸš€

Do you have any questions about these decisions before diving into implementation?
